var documenterSearchIndex = {"docs":
[{"location":"#ImageGather.jl-documentation","page":"Home","title":"ImageGather.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ImageGather.jl provides computational QC tools for wave-equation based inversion. Namely we provides two main widely used workflows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Surface offset gathers (also called surface common image gather). Surface gather compute images of (RTMs) for different offset to verify the accuracy of the background velocity. The method we implement here is based on the double-rtm method Matteo Giboli, Reda Baina, Laurence Nicoletis, Bertrand Duquet (2012) that allows the computation of the gather with two RTMs only instead of one per offset (or offset bin).\nSubsurface offset gathers (also called subsurface common image gather) Raanan Dafni, William W Symes (2018).","category":"page"},{"location":"#Surface-offset-gathers","page":"Home","title":"Surface offset gathers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"surface_gather\ndouble_rtm_cig","category":"page"},{"location":"#ImageGather.surface_gather","page":"Home","title":"ImageGather.surface_gather","text":"surface_gather(model, q, data; offsets=nothing, options=Options())\n\nCompute the surface offset gathers volume (nx (X ny) X nz X no) for via the double rtm method whith no offsets.\n\nParameters\n\nmodel: JUDI Model structure.\nq: Source, judiVector.\ndata: Obeserved data, judiVector.\noffsets: List of offsets to compute the gather at. Optional (defaults to 0:10*model.d:model.extent)\noptions: JUDI Options structure.\n\n\n\n\n\n","category":"function"},{"location":"#ImageGather.double_rtm_cig","page":"Home","title":"ImageGather.double_rtm_cig","text":"double_rtm_cig(model, q, data, offsets, options)\n\nCompute the single shot contribution to the surface offset gather via double rtm. This single source contribution consists of the following steps:\n\nMute direct arrival in the data.\nCompute standard RTM R.\nCompute the offset RTM R_o for the the weighted data where each trace is weighted by its offset (rec_x - src_x).\nCompute the envelope R_e = mathcalE(R) and R_oe = mathcalE(R_o).\nCompute the offset map fracR_e odot R_oeR_e odot R_e + epsilon.\nApply illumination correction and laplace filter R_l = mathcalD Delta R.\nCompute each offset contribution mathcalI h = R_l odot deltaha - h_tol delta_h.\nReturn mathcalI.\n\n\n\n\n\n","category":"function"},{"location":"#Subsurface-offset-gathers","page":"Home","title":"Subsurface offset gathers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"judiExtendedJacobian","category":"page"},{"location":"#ImageGather.judiExtendedJacobian","page":"Home","title":"ImageGather.judiExtendedJacobian","text":"J = judiExtendedJacobian(F, q, offsets; options::JUDIOptions)\n\nExtended jacobian (extended Born modeling operator) for subsurface horsizontal offsets offsets. Its adjoint comput the subsurface common offset volume. In succint way, the extened born modeling Operator can summarized in a linear algebra frmaework as:\n\n\n\n\n\n","category":"type"},{"location":"#Utility-functions","page":"Home","title":"Utility functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [ImageGather]\nPages = [\"utils.jl\"]","category":"page"},{"location":"#ImageGather.delta_h-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Number, Number}} where T","page":"Home","title":"ImageGather.delta_h","text":"delta_h(ha, h, tol)\n\nCompute the binary mask where ha is within tol of h.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.envelope-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.envelope","text":"envelope(x)\n\nEnvelope of a vector or a 1D vector (see DSP hilbert)\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.envelope-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.envelope","text":"envelope(x)\n\nEnvelope of a vector or a 2D matrix. The envelope over the first dimension is taken for a 2D matrix (see DSP hilbert)\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.laplacian-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.laplacian","text":"laplacian(image; hx=1, hy=1)\n\n2D laplacian of an image with grid spacings (hx, hy)\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.mute!-Union{Tuple{Ts}, Tuple{To}, Tuple{AbstractMatrix{Ts}, Vector{To}}} where {To, Ts}","page":"Home","title":"ImageGather.mute!","text":"mute!(shot, offsets;vp=1500, t0=1/10, dt=0.004)\n\nIn place direct wave muting of a shot record with water sound speed vp, time sampling dt and firing time t0.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.mute-Union{Tuple{Ts}, Tuple{To}, Tuple{AbstractMatrix{Ts}, Vector{To}}} where {To, Ts}","page":"Home","title":"ImageGather.mute","text":"mute(shot, offsets;vp=1500, t0=1/10, dt=0.004)\n\nDirect wave muting of a shot record with water sound speed vp, time sampling dt and firing time t0.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.mv_avg_2d-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.mv_avg_2d","text":"mv_avg_2d(x; k=5)\n\n2D moving average with a square window of width k\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.offset_map-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Home","title":"ImageGather.offset_map","text":"offset_map(rtm, rtmo; scale=0)\n\nReturn the regularized least-square division of rtm and rtmo. The regularization consists of the envelope and moving average followed by the least-square division surface_gather\n\n\n\n\n\n","category":"method"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
