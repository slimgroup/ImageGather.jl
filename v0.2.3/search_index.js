var documenterSearchIndex = {"docs":
[{"location":"#ImageGather.jl-documentation","page":"Home","title":"ImageGather.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API reference","category":"page"},{"location":"#Surface-offset-gathers","page":"Home","title":"Surface offset gathers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [ImageGather]\nPages = [\"surface_gather.jl\"]","category":"page"},{"location":"#ImageGather.double_rtm_cig-Tuple{Any, JUDI.judiVector, JUDI.judiVector, Any, Any}","page":"Home","title":"ImageGather.double_rtm_cig","text":"double_rtm_cig(model, q, data, offsets, options)\n\nCompute the single shot contribution to the surface offset gather via double rtm. This single source contribution consists of the following steps:\n\nMute direct arrival in the data.\nCompute standard RTM R.\nCompute the offset RTM R_o for the the weighted data where each trace is weighted by its offset (rec_x - src_x).\nCompute the envelope R_e = mathcalE(R) and R_oe = mathcalE(R_o).\nCompute the offset map fracR_e odot R_oeR_e odot R_e + epsilon.\nApply illumination correction and laplace filter R_l = mathcalD Delta R.\nCompute each offset contribution mathcalI h = R_l odot deltaha - h_tol delta_h.\nReturn mathcalI.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.surface_gather-Tuple{JUDI.Model, JUDI.judiVector, JUDI.judiVector}","page":"Home","title":"ImageGather.surface_gather","text":"surface_gather(model, q, data; offsets=nothing, options=Options())\n\nCompute the surface offset gathers volume (nx (X ny) X nz X no) for via the double rtm method whith no offsets.\n\nParameters\n\nmodel: JUDI Model structure.\nq: Source, judiVector.\ndata: Obeserved data, judiVector.\noffsets: List of offsets to compute the gather at. Optional (defaults to 0:10*model.d:model.extent)\noptions: JUDI Options structure.\n\n\n\n\n\n","category":"method"},{"location":"#Utility-functions","page":"Home","title":"Utility functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [ImageGather]\nPages = [\"utils.jl\"]","category":"page"},{"location":"#ImageGather.delta_h-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Number, Number}} where T","page":"Home","title":"ImageGather.delta_h","text":"delta_h(ha, h, tol)\n\nCompute the binary mask where ha is within tol of h.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.envelope-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.envelope","text":"envelope(x)\n\nEnvelope of a vector or a 1D vector (see DSP hilbert)\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.envelope-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.envelope","text":"envelope(x)\n\nEnvelope of a vector or a 2D matrix. The envelope over the first dimension is taken for a 2D matrix (see DSP hilbert)\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.laplacian-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.laplacian","text":"laplacian(image; hx=1, hy=1)\n\n2D laplacian of an image with grid spacings (hx, hy)\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.mute!-Union{Tuple{Ts}, Tuple{To}, Tuple{AbstractMatrix{Ts}, Vector{To}}} where {To, Ts}","page":"Home","title":"ImageGather.mute!","text":"mute!(shot, offsets;vp=1500, t0=1/10, dt=0.004)\n\nIn place direct wave muting of a shot record with water sound speed vp, time sampling dt and firing time t0.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.mute-Union{Tuple{Ts}, Tuple{To}, Tuple{AbstractMatrix{Ts}, Vector{To}}} where {To, Ts}","page":"Home","title":"ImageGather.mute","text":"mute(shot, offsets;vp=1500, t0=1/10, dt=0.004)\n\nDirect wave muting of a shot record with water sound speed vp, time sampling dt and firing time t0.\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.mv_avg_2d-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"ImageGather.mv_avg_2d","text":"mv_avg_2d(x; k=5)\n\n2D moving average with a square window of width k\n\n\n\n\n\n","category":"method"},{"location":"#ImageGather.offset_map-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Home","title":"ImageGather.offset_map","text":"offset_map(rtm, rtmo; scale=0)\n\nReturn the regularized least-square division of rtm and rtmo. The regularization consists of the envelope and moving average followed by the least-square division 'surface_gather'\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
